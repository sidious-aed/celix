#include "./machine.h"

vast poly_alert(source relay) {
	quad naof_secs = get_naof_secs(relay);
	sec poly_space[10000];
	quad poly_site = 0;
	add_to_entree("<--> | ", 7, poly_space, &poly_site);
	add_to_entree(relay, naof_secs, poly_space, &poly_site);
	add_to_entree("\n", 1, poly_space, &poly_site);
	syscall(unix_write, 1, poly_space, poly_site);
	syscall(unix_exit_group, 0);
}

quadrant main(quadrant naof_params, source_vecter params) {
  if(naof_params < 4) {
    printf("params | 3-*\n");
    printf("1 | asm-file\n");
    printf("2 | secs-file\n");
    printf("3 | init-bs (base-16)\n");
		printf("(4-*) | params\n");
    return;
  }
  ip_file asm_file = syscall(unix_open, params[1], archive_read);
  quadrant naof_asm_secs = syscall(unix_lseek, asm_file, 0, seek_completion);
	//printf("naof-asm-secs | %lu\n", naof_asm_secs);
	source asms = syscall(unix_mmap, non, (naof_asm_secs + 1), map_rws, map_console, asm_file, 0);
	//syscall(unix_write, 1, asms, naof_asm_secs);
	writer grid = 0;
	writer mparams = 0;
	create_vecter(&grid, 0x10, 1000, &mparams);
	quad naof_mparams = naof_params - 4;
	quad psite = 0;
	while(true) {
		if(psite == naof_mparams) {
			break;
		}
		quad param_site = psite + 4;
		quad naof_param_secs = get_naof_secs(params[param_site]);
		source entree = 0;
		get_grid_secs(&grid, (naof_param_secs + 1), &entree);
		wide_com(params[param_site], entree, naof_param_secs);
		//printf("entree | %s\n", entree);
		//getc(stdin);
		quad param[2];
		param[0] = entree;
		param[1] = naof_param_secs;
		add_to_vecter(&grid, param, &mparams);
		psite += 1;
	}
	//printf("naof-params | %lu\n", mparams[2]);
	writer mach = 0;
	create_vecter(&grid, 1, 1000, &mach);
	writer components = 0;
	create_vecter(&grid, 0x28, 100, &components);
	quad init_bs = 0;
	entree_to_number(params[3], get_naof_secs(params[3]), 16, &init_bs);
	writer entrees = 0;
	create_vecter(&grid, 0x18, 1000, &entrees);
	writer quads = 0;
	create_vecter(&grid, 0x18, 1000, &quads);
	writer stats = 0;
	create_vecter(&grid, 0x18, 1000, &stats);
	writer futures = 0;
	create_vecter(&grid, 0x38, 1000, &futures);

	quad bs = init_bs;
	quad ms = 0; // ms | machine-site
	quad sr = 0; // sr | stack-reference
	sec cp[10000]; // cp | clerk-space
	quad cp_site = 0;
	sec msecs[10000];
	quad msite = 0;
	quad site = 0;
	while(true) {
		cp_site = 0;
		add_to_entree("bs | ", 5, cp, &cp_site);
		cp_site += number_to_entree(bs, (cp + cp_site), 16);
		add_to_entree("\n", 1, cp, &cp_site);
		//syscall(unix_write, 1, cp, cp_site);
		source sect = (asms + site);
		squad sect_site = seek_space("\n", 1, sect, (naof_asm_secs - site));
		syscall(unix_write, 1, sect, (sect_site + 1));
		site += (sect_site + 1);
		if(sect_site == 0) {
			continue;
		}
		//printf("ms | %lu\n", ms);
		quad b16_site = 0;
		components[2] = 0;
		quad is_params = false;
		quad comp_site = 0;
		while(true) {
			if(comp_site >= sect_site) {
				break;
			}
			source sect_at = (sect + comp_site);
			squad csite = seek_space(" ", 1, (sect_at), (sect_site - comp_site));
			//printf("csite | %lu\n", csite);
			if(csite == code_a) {
				csite = (sect_site - comp_site);
			}
			//syscall(unix_write, 1, (sect_at), (csite));
			//syscall(unix_write, 1, "\n", 1);
			quad component[5];
			source entree = 0;
			if(sect_at[0] == '$') {
				quad param_site = 0;
				entree_to_number((sect_at + 1), (csite - 1), 16, &param_site);
				//printf("param-site | %lu\n", param_site);
				if(param_site >= mparams[2]) {
					cp_site = 0;
					// b | 11 | 2 | 13 | 17 <--> is to 27
					add_to_entree("need param ", 0xb, cp, &cp_site);
					cp_site += number_to_entree(param_site, (cp + cp_site), 16);
					add_to_entree(".", 1, cp, &cp_site);
					poly_alert(cp);
				}
				//getc(stdin);
				writer param = (mparams + 3) + (param_site * 2);
				get_grid_secs(&grid, (param[1] + 1), &entree);
				wide_com(param[0], (entree), param[1]);
				component[1] = param[1];
				is_params = true;
			} else {
				get_grid_secs(&grid, (csite + 1), &entree);
				wide_com(sect_at, (entree), csite);
				component[1] = csite;
			}
			//printf("entree | %s\n", entree);
			component[0] = entree;
			//syscall(unix_write, 1, component[0], csite);
			//syscall(unix_write, 1, "\n", 1);
			quad is_b16 = is_base((component[0]), component[1], 16);
			//printf("is-b16 | %lu\n", is_b16);
			component[2] = is_b16;
			component[3] = 0;
			if(component[2]) {
				quad number = 0;
				entree_to_number(component[0], component[1], 16, &number);
				//printf("number | %lu\n", number);
				component[3] = number;
				b16_site = components[2];
			}
			component[4] = comp_site;
			//see_space("component", component, 0x28);
			add_to_vecter(&grid, component, &components);
			comp_site += (csite + 1);
			//printf("comp-site | %lu\n", comp_site);
			//getc(stdin);
		}
		if(b16_site == 0) {
			b16_site = code_b;
		}
		//printf("b16-site | %lu\n", b16_site);
		msite = 0;
		quad naof_comps = components[2];
		writer comp0 = (components + 3);
		writer comp1 = (components + 3) + (5);
		writer comp2 = (components + 3) + (10);
		writer comp3 = (components + 3) + (15);
		cp_site = 0;
		//printf("first-con | %c\n", (((source)(comp0[0])))[0]);
		if(((((source)(comp0[0])))[0] == '#') || compair_spaces(comp0[0], comp0[1], "#", 1)) {
			// explicit comment aura-clerically registered.
			//getc(stdin);
		} else if(compair_spaces(comp0[0], comp0[1], "lea", 3)) {
			if(naof_comps != 4) {
				poly_alert("lea params are add-site, src-register, dest-register.");
			}
			add_to_entree(comp2[0], comp2[1], cp, &cp_site);
			add_to_entree("-", 1, cp, &cp_site);
			add_to_entree(comp3[0], comp3[1], cp, &cp_site);
			//syscall(unix_write, 1, cp, cp_site);
			//syscall(unix_write, 1, "\n", 1);
			msite = asm_lea_registers(cp, cp_site, comp1[3], msecs);
		} else if(compair_spaces(comp0[0], comp0[1], "mov", 3)) {
			if(naof_comps == 3) {
				if(b16_site == code_b) {
					add_to_entree(comp1[0], comp1[1], cp, &cp_site);
					add_to_entree("-", 1, cp, &cp_site);
					add_to_entree(comp2[0], comp2[1], cp, &cp_site);
					//syscall(unix_write, 1, cp, cp_site);
					//syscall(unix_write, 1, "\n", 1);
					msite = asm_mov_registers(cp, cp_site, msecs);
				} else {
					//printf("set-register | %s\n", comp1[0]);
					msite = asm_set_register(comp1[3], comp2[0], comp2[1], msecs);
				}
			} else if(naof_comps == 4) {
				if(b16_site == 1) {
					add_to_entree(comp2[0], comp2[1], cp, &cp_site);
					add_to_entree("-", 1, cp, &cp_site);
					add_to_entree(comp3[0], comp3[1], cp, &cp_site);
					//syscall(unix_write, 1, cp, cp_site);
					//syscall(unix_write, 1, "\n", 1);
					msite = asm_mov_castl_registers(cp, cp_site, comp1[3], msecs);
				} else if(b16_site == 2) {
					add_to_entree(comp1[0], comp1[1], cp, &cp_site);
					add_to_entree("-", 1, cp, &cp_site);
					add_to_entree(comp3[0], comp3[1], cp, &cp_site);
					//syscall(unix_write, 1, cp, cp_site);
					//syscall(unix_write, 1, "\n", 1);
					msite = asm_mov_castr_registers(cp, cp_site, comp2[3], msecs);
				}
			} else {
				poly_alert("mov can except (constant, dest-register), (src-register, dest-register), (cast-site src-register dest-register), and (src-register, cast-site, dest-register).");
			}
		} else if(compair_spaces(comp0[0], comp0[1], "movs", 4)) { // movs | move-sec
			if(b16_site == 1) {
				add_to_entree(comp2[0], comp2[1], cp, &cp_site);
				add_to_entree("-", 1, cp, &cp_site);
				add_to_entree(comp3[0], comp3[1], cp, &cp_site);
				//syscall(unix_write, 1, cp, cp_site);
				//syscall(unix_write, 1, "\n", 1);
				msite = asm_mov_sec_castl_registers(cp, cp_site, comp1[3], msecs);
			} else if(b16_site == 2) {
				add_to_entree(comp1[0], comp1[1], cp, &cp_site);
				add_to_entree("-", 1, cp, &cp_site);
				add_to_entree(comp3[0], comp3[1], cp, &cp_site);
				//syscall(unix_write, 1, cp, cp_site);
				//syscall(unix_write, 1, "\n", 1);
				msite = asm_mov_sec_castr_registers(cp, cp_site, comp2[3], msecs);
			}
		} else if(compair_spaces(comp0[0], comp0[1], "sub", 3)) {
			if(b16_site == code_b) {
				cp_site = 0;
				add_to_entree(comp1[0], comp1[1], cp, &cp_site);
				add_to_entree("-", 1, cp, &cp_site);
				add_to_entree(comp2[0], comp2[1], cp, &cp_site);
				//syscall(unix_write, 1, cp, cp_site);
				//syscall(unix_write, 1, "\n", 1);
				msite = asm_sub_registers(cp, cp_site, msecs);
			} else {
				msite = asm_sub_const_register(comp2[0], comp2[1], comp1[3], msecs);
			}
		} else if(compair_spaces(comp0[0], comp0[1], "add", 3)) {
			if(b16_site == code_b) {
				cp_site = 0;
				add_to_entree(comp1[0], comp1[1], cp, &cp_site);
				add_to_entree("-", 1, cp, &cp_site);
				add_to_entree(comp2[0], comp2[1], cp, &cp_site);
				//syscall(unix_write, 1, cp, cp_site);
				//syscall(unix_write, 1, "\n", 1);
				msite = asm_add_registers(cp, cp_site, msecs);
			} else {
				msite = asm_add_const_register(comp2[0], comp2[1], comp1[3], msecs);
			}
		} else if(compair_spaces(comp0[0], comp0[1], "and", 3)) {
			if(b16_site == code_b) {
				cp_site = 0;
				add_to_entree(comp1[0], comp1[1], cp, &cp_site);
				add_to_entree("-", 1, cp, &cp_site);
				add_to_entree(comp2[0], comp2[1], cp, &cp_site);
				//syscall(unix_write, 1, cp, cp_site);
				//syscall(unix_write, 1, "\n", 1);
				msite = asm_and_registers(cp, cp_site, msecs);
			} else {
				msite = asm_and_const_register(comp2[0], comp2[1], comp1[3], msecs);
			}
		} else if(compair_spaces(comp0[0], comp0[1], "xor", 3)) {
			if(b16_site == code_b) {
				cp_site = 0;
				add_to_entree(comp1[0], comp1[1], cp, &cp_site);
				add_to_entree("-", 1, cp, &cp_site);
				add_to_entree(comp2[0], comp2[1], cp, &cp_site);
				//syscall(unix_write, 1, cp, cp_site);
				//syscall(unix_write, 1, "\n", 1);
				msite = asm_xor_registers(cp, cp_site, msecs);
			} else {
				msite = asm_xor_const_register(comp2[0], comp2[1], comp1[3], msecs);
			}
		} else if(compair_spaces(comp0[0], comp0[1], "nao", 3)) { // nao | naoify (xor self)
			cp_site = 0;
			add_to_entree(comp1[0], comp1[1], cp, &cp_site);
			add_to_entree("-", 1, cp, &cp_site);
			add_to_entree(comp2[0], comp2[1], cp, &cp_site);
			//syscall(unix_write, 1, cp, cp_site);
			//syscall(unix_write, 1, "\n", 1);
			msite = asm_xor_registers(cp, cp_site, msecs);
		} else if(compair_spaces(comp0[0], comp0[1], "or", 2)) {
			if(b16_site == code_b) {
				cp_site = 0;
				add_to_entree(comp1[0], comp1[1], cp, &cp_site);
				add_to_entree("-", 1, cp, &cp_site);
				add_to_entree(comp2[0], comp2[1], cp, &cp_site);
				//syscall(unix_write, 1, cp, cp_site);
				//syscall(unix_write, 1, "\n", 1);
				msite = asm_or_registers(cp, cp_site, msecs);
			} else {
				msite = asm_or_const_register(comp2[0], comp2[1], comp1[3], msecs);
			}
		} else if(compair_spaces(comp0[0], comp0[1], "not", 3)) {
			msite = asm_not_register(comp1[0], comp1[1], msecs);
		} else if(compair_spaces(comp0[0], comp0[1], "fact", 4)) { // fact | (facter|multiply)
			cp_site = 0;
			add_to_entree(comp2[0], comp2[1], cp, &cp_site);
			add_to_entree("-", 1, cp, &cp_site);
			add_to_entree(comp3[0], comp3[1], cp, &cp_site);
			//syscall(unix_write, 1, cp, cp_site);
			//syscall(unix_write, 1, "\n", 1);
			msite = asm_multiply_registers(comp1[3], cp, cp_site, msecs);
		} else if(compair_spaces(comp0[0], comp0[1], "dev", 3)) { // dev | (unfacter|devide) | castl register with rax.
			msite = asm_divide_castl_to_returns(comp1[3], comp2[0], comp2[1], msecs);
		} else if(compair_spaces(comp0[0], comp0[1], "s", 1)) { // s | (stat|marker)
			quad stat[3];
			stat[0] = comp1[0];
			stat[1] = comp1[1];
			stat[2] = bs;
			add_to_vecter(&grid, stat, &stats);
		} else if(compair_spaces(comp0[0], comp0[1], "st", 2)) { // st | (stay-to)
			msite = asm_stay_to(comp1[0], comp1[1], bs, 0, msecs);
			quad ct[6];
			ct[0] = 2;
			ct[1] = comp2[0];
			ct[2] = comp2[1];
			ct[3] = ms;
			ct[4] = bs;
			ct[5] = comp1[0];
			ct[6] = comp1[1];
			add_to_vecter(&grid, ct, &futures);
		} else if(compair_spaces(comp0[0], comp0[1], "dst", 3)) { // dst | (dynamic-stay-to)
			cp_site = 0;
			add_to_entree(comp1[0], comp1[1], cp, &cp_site);
			add_to_entree("-", 1, cp, &cp_site);
			add_to_entree(comp2[0], comp2[1], cp, &cp_site);
			//syscall(unix_write, 1, cp, cp_site);
			//syscall(unix_write, 1, "\n", 1);
			msite = asm_dynamic_stay_to("jmpq-r11", 8, msecs);
		} else if(compair_spaces(comp0[0], comp0[1], "ct", 2)) { // ct | (call-to)
			quad ct[6];
			ct[0] = 1;
			ct[1] = comp1[0];
			ct[2] = comp1[1];
			ct[3] = ms;
			ct[4] = bs;
			ct[5] = 0;
			ct[6] = 0;
			add_to_vecter(&grid, ct, &futures);
			msite = asm_call_to(bs, 0, msecs);
		} else if(compair_spaces(comp0[0], comp0[1], "dct", 3)) { // dct | (dynamic-call-to)
			msite = asm_dynamic_call_to(comp1[0], comp1[1], msecs);
		} else if(compair_spaces(comp0[0], comp0[1], "sys", 3)) { // sys | syscall
			msite = asm_syscall(msecs);
		} else if(compair_spaces(comp0[0], comp0[1], "ret", 3)) { // ret | return
			msite = asm_return(msecs);
		} else if(compair_spaces(comp0[0], comp0[1], "ss", 2)) { // ss | store-state
			msite = asm_store_state(msecs);
		} else if(compair_spaces(comp0[0], comp0[1], "rs", 2)) { // rs | store-state
			msite = asm_restore_state(msecs);
		} else if(compair_spaces(comp0[0], comp0[1], "naof", 4)) { // naof | number-of | in this focuser naof-secs, so 90 100 is 256 nops.
			sec mach_sec = comp1[3];
			//printf("mach-sec | %u\n", mach_sec);
			//expand_for_string_to_sec_vecter(&grid, comp2[3], &mach);
			//source mach_at = ((mach + 3) + mach[2]);
			//replicate(mach_sec, mach_at, comp2[3]);
			//printf("mach-site | %lu\n", mach[2]);
			//mach[2] += comp2[3];
			replicate_to_sec_vecter(&grid, mach_sec, comp2[3], &mach);
			bs += comp2[3];
			ms += comp2[3];
		} else if(compair_spaces(comp0[0], comp0[1], "aqs", 3)) { // aqs | auto-quad-source
			quad aqs[3];
			aqs[0] = comp1[0];
			aqs[1] = comp1[1];
			aqs[2] = sr;
			add_to_vecter(&grid, aqs, &quads);
			sr += 8;
		} else if(compair_spaces(comp0[0], comp0[1], "lq", 2)) { // lq | leeve-quad
			quad qsite = 0;
			while(true) {
				if(qsite == quads[2]) {
					break;
				}
				writer qua = (quads + 3) + (qsite * 3); // qua --- ke for aqsing <--> * sirindiplea ... like final fantasy
				if(compair_spaces(comp1[0], comp1[1], qua[0], qua[1])) {
					cp_site = 0;
					add_to_entree("rsp-", 4, cp, &cp_site);
					add_to_entree(comp2[0], comp2[1], cp, &cp_site);
					msite = asm_lea_registers(cp, cp_site, qua[2], msecs);
				}
				qsite += 1;
			}
		} else if(compair_spaces(comp0[0], comp0[1], "mq", 2)) { // mq | move-quad
			quad is_castr = true;
			source register_name = comp1[0];
			quad naof_register_name_secs = comp1[1];
			source source_name = comp2[0];
			quad naof_source_name_secs = comp2[1];
			squad registers_site = get_entree_site(gnu_registers, gnu_registers_naof_secs, naof_gnu_registers, register_name, naof_register_name_secs);
			if(registers_site == -1) {
				is_castr = false;
				source_name = comp1[0];
				naof_source_name_secs = comp1[1];
				register_name = comp2[0];
				naof_register_name_secs = comp2[1];
				registers_site = get_entree_site(gnu_registers, gnu_registers_naof_secs, naof_gnu_registers, register_name, naof_register_name_secs);
				if(registers_site == -1) {
					poly_alert("mq needs one of the two params to be a gnu-64-general register. and the other, a aqs.");
				}
			}
			//printf("source-name | %s\n", source_name);
			//printf("naof-source-name-secs | %lu\n", naof_source_name_secs);
			//printf("is-castr | %lu\n", is_castr);
			quad qsite = 0;
			while(true) {
				if(qsite == quads[2]) {
					break;
				}
				writer qua = (quads + 3) + (qsite * 3); // qua --- ke for aqsing <--> * sirindiplea ... like final fantasy
				printf("qua | %s\n", qua[0]);
				if(compair_spaces(source_name, naof_source_name_secs, qua[0], qua[1])) {
					cp_site = 0;
					if(is_castr) {
						add_to_entree(register_name, naof_register_name_secs, cp, &cp_site);
						add_to_entree("-rsp", 4, cp, &cp_site);
						msite = asm_mov_castr_registers(cp, cp_site, qua[2], msecs);
						//see_space("msecs", msecs, msite);
					} else {
						add_to_entree("rsp-", 4, cp, &cp_site);
						add_to_entree(register_name, naof_register_name_secs, cp, &cp_site);
						msite = asm_mov_castl_registers(cp, cp_site, qua[2], msecs);
						//see_space("msecs", msecs, msite);
					}
				}
				qsite += 1;
			}
		} else if(compair_spaces(comp0[0], comp0[1], "secs", 4)) {
			quad naof_csecs = (naof_comps - 1);
			quad csec_site = 0;
			while(true) {
				if(csec_site == naof_csecs) {
					break;
				}
				writer csec_comp = (components + 3) + 5 + (csec_site * 5);
				add_string_to_sec_vecter(&grid, (csec_comp + 3), 1, &mach);
				csec_site += 1;
			}
			bs += (naof_csecs);
			ms += (naof_csecs);
		} else if(compair_spaces(comp0[0], comp0[1], "isr", 3)) { // isr | incriment-stack-reference
			sr += comp1[3];
		} else if(compair_spaces(comp0[0], comp0[1], "lent", 4)) { // lent | leave-entree
			quad lent[6];
			source entree = 0;
			get_grid_secs(&grid, (comp1[1] + 1), &entree);
			wide_com(comp1[0], entree, comp1[1]);
			lent[0] = 0; // entree-type
			lent[1] = entree;
			lent[2] = comp1[1];
			lent[3] = ms;
			lent[4] = comp2[0];
			lent[5] = comp2[1];
			lent[6] = 0;
			add_to_vecter(&grid, lent, &futures);
			cp_site = 0;
			add_to_entree("rsp", 3, cp, &cp_site);
			add_to_entree("-", 1, cp, &cp_site);
			add_to_entree(comp2[0], comp2[1], cp, &cp_site);
			//syscall(unix_write, 1, cp, cp_site);
			//syscall(unix_write, 1, "\n", 1);
			msite = asm_lea_registers(cp, cp_site, 0, msecs);
		} else if(compair_spaces(comp0[0], comp0[1], "ent", 3)) { // ent | entree
			quad ent[2];
			ent[0] = comp1[0];
			ent[1] = comp1[1];
			ent[2] = sr;
			add_to_vecter(&grid, ent, &entrees);
			quad naof_sections = naof_comps - 2;
			if(naof_sections <= 0) {
				poly_alert("not enough components for ent | for ent | symbol then entree");
			}
			quad et_co_site = naof_comps - 1;
			quad co_site = 2;
			sec q[8];
			writer fq = q;
			fq[0] = 0;
			quad qsite = 0;
			source cat = 0;
			quad naof_cat_secs = 0;
			quad cat_site = 0;
			while(true) {
				quad is_com = false;
				quad is_qcom = false;
				//printf("co-site | %lu\n", co_site);
				if(cat_site == naof_cat_secs) {
					cat = 0;
				}
				if(cat == 0) {
					if(co_site < naof_comps) {
						writer cat_comp = (components + 3) + (co_site * 5);
						cat = cat_comp[0];
						naof_cat_secs = cat_comp[1];
						//printf("cat-at | %s\n", cat);
						//printf("naof-cat-secs | %lu\n", naof_cat_secs);
						//if((co_site != 2) && (co_site != et_co_site)) {
						if((co_site != 2)) {
							q[qsite] = ' ';
							qsite += 1;
							if(qsite == 8) {
								is_qcom = true;
							}
						}
						cat_site = 0;
						co_site += 1;
					} else {
						is_com = true;
						is_qcom = true;
					}
				}
				if((cat != 0) && (is_qcom == false)) {
					//printf("qsite | %lu\n", qsite);
					sec rune = cat[cat_site];
					cat_site += 1;
					if((rune == '\\') && (cat_site < naof_cat_secs)) {
						sec cont = cat[cat_site];
						cat_site += 1;
						if(cont == 'n') {
							rune = '\n';
						} else if(cont == 't') {
							rune = '\t';
						} else if(cont == '\\') {
							rune = '\\';
						}
					}
					q[qsite] = rune;
					qsite += 1;
					if(qsite == 8) {
						is_qcom = true;
					}
				}
				if(is_qcom) {
					msite = asm_set_register(fq[0], "r8", 2, msecs);
					add_string_to_sec_vecter(&grid, msecs, msite, &mach);
					bs += msite;
					ms += (msite);
					msite = asm_mov_castr_registers("r8-rsp", 6, sr, msecs);
					add_string_to_sec_vecter(&grid, msecs, msite, &mach);
					bs += msite;
					ms += (msite);
					sr += 8;
					qsite = 0;
					fq[0] = 0;
				}
				if(is_com) {
					msite = asm_xor_registers("r8-r8", 5, msecs);
					add_string_to_sec_vecter(&grid, msecs, msite, &mach);
					bs += msite;
					ms += (msite);
					msite = asm_mov_castr_registers("r8-rsp", 6, sr, msecs);
					add_string_to_sec_vecter(&grid, msecs, msite, &mach);
					bs += msite;
					ms += (msite);
					msite = 0;
					sr += 8;
					break;
				}
			}
			/*
			*/
		}
		if(msite > 0) {
			//see_space("msecs", msecs, msite);
			add_string_to_sec_vecter(&grid, msecs, msite, &mach);
			bs += msite;
			ms += (msite);
		}
		//printf("mach-site | %lu\n", mach[2]);
		if(site >= naof_asm_secs) {
			break;
		}
		//printf("\n");
	}

	//log_heading("entrees");
	site = 0;
	while(true) {
		if(site == entrees[2]) {
			break;
		}
		writer ent = (entrees + 3) + (site * 3);
		//printf("entree-%lu | %s | %lu\n", site, ent[0], ent[2]);
		site += 1;
	}

	log_heading("quads");
	site = 0;
	while(true) {
		if(site == quads[2]) {
			break;
		}
		writer aqs = (quads + 3) + (site * 3);
		printf("quad-%lu | %s | %lu\n", site, aqs[0], aqs[2]);
		site += 1;
	}

	//log_heading("stats");
	site = 0;
	while(true) {
		if(site == stats[2]) {
			break;
		}
		writer ent = (stats + 3) + (site * 3);
		//printf("stat-%lu | %s | %lu\n", site, ent[0], ent[2]);
		site += 1;
	}

	source last_mach_com = 0;
	quad last_mach_com_naof_secs = 0;
	//log_heading("futures");
	site = 0;
	while(true) {
		if(site == futures[2]) {
			break;
		}
		writer future = (futures + 3) + (site * 7);
		//see_space("future", future, 0x20);
		if(future[0] == 0) {
			//printf("entree-name | %s\n", future[1]);
			//printf("naof-entree-secs | %lu\n", future[2]);
			quad esite = 0;
			while(true) {
				if(esite == entrees[2]) {
					break;
				}
				writer ent = (entrees + 3) + (esite * 3);
				//printf("entree-%lu | %s | %lu\n", site, ent[0], ent[2]);
				if(compair_spaces(future[1], future[2], ent[0], ent[1])) {
					//printf("entree matched for lent.\n");
					cp_site = 0;
					add_to_entree("rsp", 3, cp, &cp_site);
					add_to_entree("-", 1, cp, &cp_site);
					add_to_entree(future[4], future[5], cp, &cp_site);
					//syscall(unix_write, 1, cp, cp_site);
					//syscall(unix_write, 1, "\n", 1);
					msite = asm_lea_registers(cp, cp_site, ent[2], msecs);
					//printf("msecs | ");
					//see_encoded(msecs, msite, 16);
					//printf("\n");
					//printf("mach-site | %lu\n", future[3]);
					source mach_com = (((source)(mach + 3)) + future[3]);
					//source mach_com = (mach + 3);
					//printf("mach-com | ");
					//see_encoded(mach_com, msite, 16);
					//printf("\n");
					//com_string_to_sec_vecter(&grid, msecs, msite, &mach, futures[3]);
					wide_com(msecs, (mach_com), msite);
					//printf("mach-com | ");
					//see_encoded(mach_com, msite, 16);
					//printf("\n");
				}
				esite += 1;
			}
		} else if(future[0] == 1) {
			//printf("entree-name | %s\n", future[1]);
			//printf("naof-entree-secs | %lu\n", future[2]);
			quad st_site = 0;
			while(true) {
				if(st_site == stats[2]) {
					break;
				}
				writer stat = (stats + 3) + (st_site * 3);
				//printf("stat-%lu | %s | %lu\n", site, stat[0], stat[2]);
				if(compair_spaces(future[1], future[2], stat[0], stat[1])) {
					//printf("stat matched for ct.\n");
					//printf("stack-site | %lu\n", future[3]);
					//printf("stat-stack-site | %lu\n", stat[2]);
					msite = asm_call_to(future[4], stat[2], msecs);
					//printf("msecs | ");
					//see_encoded(msecs, msite, 16);
					//printf("\n");
					source mach_com = (((source)(mach + 3)) + future[3]);
					last_mach_com = mach_com;
					last_mach_com_naof_secs = msite;
					//printf("mach-com | ");
					//see_encoded(mach_com, msite, 16);
					//printf("\n");
					wide_com(msecs, (mach_com), msite);
					//com_string_to_sec_vecter(&grid, msecs, msite, &mach, future[3]);
					//printf("mach-com | ");
					//see_encoded(mach_com, msite, 16);
					//printf("\n");
				}
				st_site += 1;
			}
		} else if(future[0] == 2) {
			//printf("entree-name | %s\n", future[1]);
			//printf("naof-entree-secs | %lu\n", future[2]);
			quad st_site = 0;
			while(true) {
				if(st_site == stats[2]) {
					break;
				}
				writer stat = (stats + 3) + (st_site * 3);
				//printf("stat-%lu | %s | %lu\n", site, stat[0], stat[2]);
				if(compair_spaces(future[1], future[2], stat[0], stat[1])) {
					//printf("stat matched for ct.\n");
					//printf("stack-site | %lu\n", future[3]);
					//printf("stat-stack-site | %lu\n", stat[2]);
					msite = asm_stay_to(future[5], future[6], future[4], stat[2], msecs);
					//printf("msecs | ");
					//see_encoded(msecs, msite, 16);
					//printf("\n");
					source mach_com = (((source)(mach + 3)) + future[3]);
					last_mach_com = mach_com;
					last_mach_com_naof_secs = msite;
					//printf("mach-com | ");
					//see_encoded(mach_com, msite, 16);
					//printf("\n");
					wide_com(msecs, (mach_com), msite);
					//com_string_to_sec_vecter(&grid, msecs, msite, &mach, future[3]);
					//printf("mach-com | ");
					//see_encoded(mach_com, msite, 16);
					//printf("\n");
				}
				st_site += 1;
			}
		}
		site += 1;
	}

	quad mach_com = (mach + 3);
	//printf("mach-com | ");
	//see_encoded((mach + 3), mach[2], 16);
	//printf("\n");
	//see_space("mach", (mach + 3), mach[2]);
	//printf("last-mach-com | ");
	//see_encoded((last_mach_com), last_mach_com_naof_secs, 16);
	//printf("\n");
	//see_space("mach", (mach + 3), (mach[2]));
	syscall(unix_unlink, params[2]);
  archive_grid secs_file = syscall(unix_open, params[2], archive_write|archive_create, archive_jypsy);
	syscall(unix_write, secs_file, (mach + 3), mach[2]);
  syscall(unix_close, secs_file);
	/*
	*/
  return 0;
}
